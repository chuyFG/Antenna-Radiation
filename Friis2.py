import numpy as np
import matplotlib.pyplot as plt

# --- Constants ---
c = 3e8         # Speed of light
f = 2.4e9       # Frequency (Hz)
lambda_ = c/f   # Wavelength
k = 2 * np.pi / lambda_ # Wavenumber

N = 8           # Number of elements in the phased array
d = lambda_ / 2 # Spacing between elements (usually half wavelength)

# --- Define Antenna Positions ---
# Source 1
x1, y1 = -0.5, 0
# Source 2
x2, y2 = 0.5, 0

# --- Create 2D Grid ---
resolution = 200 # Increased for smoother visual
x_grid = np.linspace(-2, 2, resolution)
y_grid = np.linspace(-2, 2, resolution)
X, Y = np.meshgrid(x_grid, y_grid)

# --- Helper Function: Array Factor ---
def get_array_field(x_source, y_source, X_grid, Y_grid, N_elements, spacing):
    """
    Calculates the complex electric field at every point in the grid
    generated by a linear phased array.
    """
    # 1. Distance from source to every point
    dist = np.sqrt((X_grid - x_source)**2 + (Y_grid - y_source)**2)
    
    # 2. Angle from source to every point (Azimuth)
    # We assume the array elements are lined up along the Y-axis
    angle_to_point = np.arctan2(Y_grid - y_source, X_grid - x_source)
    
    # 3. Array Factor Calculation (Standard formula for linear array)
    # Beta is the steering phase. Set to 0 for broadside (firing to X)
    beta = 0 
    
    # The 'psi' term determines constructive/destructive interference internal to the array
    # sin(angle) used because array is along Y-axis, firing along X
    psi = k * spacing * np.sin(angle_to_point) + beta
    
    # Array Factor (AF) = sin(N*psi/2) / (N*sin(psi/2))
    # Add a tiny epsilon to denominator to avoid division by zero
    af = np.sin(N_elements * psi / 2) / (N_elements * np.sin(psi / 2) + 1e-9)
    
    # 4. Propagation Phase (k*r) and Path Loss (1/r)
    # We add 1e-9 to distance to avoid division by zero at the source itself
    propagation_term = (1 / (dist + 1e-9)) * np.exp(1j * k * dist)
    
    return af * propagation_term

# --- Compute Fields ---
# Calculate complex field from Antenna 1
field1 = get_array_field(x1, y1, X, Y, N, d)

# Calculate complex field from Antenna 2
field2 = get_array_field(x2, y2, X, Y, N, d)

# --- Superposition ---
# Add complex numbers FIRST, then take magnitude
total_field = field1 + field2

# Convert to Power (dB)
# We normalize so the max is 0 dB for visualization clarity
power_mag = np.abs(total_field)
power_db = 20 * np.log10(power_mag + 1e-9) 
power_db = power_db - np.max(power_db) # Normalize peak to 0 dB

# Clip values for better visualization (ignore extremely low nulls)
vmin = -40 

# --- Plotting ---
fig, ax = plt.subplots(figsize=(8, 6))
heatmap = ax.pcolormesh(X, Y, power_db, cmap='jet', vmin=vmin, vmax=0, shading='auto')

# Plot source locations
ax.plot(x1, y1, 'wo', markersize=5, label='Array 1')
ax.plot(x2, y2, 'wo', markersize=5, label='Array 2')

ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_title(f'Interference Pattern of Two {N}-Element Phased Arrays\n(Normalized Power dB)')
plt.colorbar(heatmap, label='Relative Power (dB)')
plt.legend()
plt.axis('equal')
plt.show()